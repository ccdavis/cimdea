searchState.loadedDescShard("flatbuffers", 0, "FlatBuffers\nForwardsSOffset is used by Follow to traverse a …\nTrait for values that must be stored in little-endian byte …\nTraces the location of data errors. Not populated for Dos …\nFileIdentifier is used by Follow to traverse a FlatBuffer: …\nFlatBufferBuilder builds a FlatBuffer through manipulating …\nFollow is a trait that allows us to access FlatBuffers in …\nFollowStart wraps a Follow impl in a struct type. This can …\nForwardsUOffset is used by Follow to traverse a …\nForwardsVOffset is used by Follow to traverse a …\nDescribes how a flatuffer is invalid and, for data errors, …\nTrait to abstract over functionality needed to write …\nSOffsetT is a relative pointer from tables to their …\nSkipFileIdentifier is used by Follow to traverse a …\nSkipRootOffset is used by Follow to traverse a FlatBuffer: …\nSkipSizePrefix is used by Follow to traverse a FlatBuffer: …\nTableFinishedWIPOffset marks a WIPOffset as being for a …\nTableUnfinishedWIPOffset marks a WIPOffset as being for an …\nUOffsetT is used represent both for relative pointers and …\nUnionWIPOffset marks a WIPOffset as being for a union …\nVOffsetT is a relative pointer in vtables to point from …\nVTableWIPOffset marks a WIPOffset as being for a vtable.\nAn iterator over a <code>Vector</code>.\nCarries the verification state. Should not be reused …\nWIPOffset contains an UOffsetT with a special meaning: it …\nReturn a wrapped value that brings its meaning as a union …\nReturns true if data contains a prefix of <code>ident</code>\nDestroy the FlatBufferBuilder, returning its internal byte …\nCreate a zero-terminated byte vector.\nCreate a utf8 string.\nCreate a vector of Push-able objects.\nCreate a vector of Push-able objects.\nPlace an EndianScalar into the provided mutable byte …\nPlace an array of EndianScalar into the provided mutable …\nEnd a Table write.\nEnd a Vector write.\nFinalize the FlatBuffer by: aligning it, pushing an …\nFinalize the FlatBuffer by: aligning it and marking the …\nFinalize the FlatBuffer by: aligning it, pushing an …\nGet the byte slice for the data that has been written …\nSafety\nSafety\nSet whether default values are stored.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new <code>VectorIter</code> from the provided slice\nCreate a FlatBufferBuilder that is ready for writing, …\nRetrieves the value at the provided <code>slot_byte_loc</code> …\nIgnore errors where a string is missing its null …\nCheck that there really is a T in there.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum “apparent” size of the message if the …\nMaximum depth of nested tables allowed in a valid …\nMaximum number of tables allowed in a valid flatbuffer.\nReturns a mutable view of a finished buffer and location …\nSafety\nSafety\nCreate a FlatBufferBuilder that is ready for writing.\nCreate a new WIPOffset.\nSafety\nRetrieve the number of vtables that have been serialized …\nSafety\nPush a Push’able value onto the front of the in-progress …\nPush a Push’able value onto the front of the in-progress …\nPush a Push’able value onto the front of the in-progress …\nRead an EndianScalar from the provided byte slice. …\nRead an EndianScalar from the provided byte slice at the …\nAssert that a field is present in the just-finished Table.\nReset the FlatBufferBuilder internal state. Use this …\nResets verifier internal state.\nGets the root of the Flatbuffer, verifying it first with …\nGets root for a trusted Flatbuffer.\nGets the root of the Flatbuffer, verifying it first with …\nRuns the verifier for this type, assuming its at position …\nSafety\nGets the root of a size prefixed Flatbuffer, verifying it …\nGets root for a trusted, size prefixed, Flatbuffer.\nGets the root of a size prefixed Flatbuffer, verifying it …\nStart a Table write.\nStart a Vector write.\nGet the byte slice for the data that has been written, …\nGet the underlying value.\nRuns the union variant’s type’s verifier assuming the …\nCreate a FlatBufferBuilder that is ready for writing, with …")
searchState.loadedDescShard("hashlink", 0, "A version of <code>HashMap</code> that has a user controllable order …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInserts the given key / value pair at the <em>back</em> of the …\nReplaces this entry’s value with the provided value.\nInsert’s the key for this vacant entry paired with the …\nSimilar to <code>OccupiedEntry::replace_entry</code>, but <em>does</em> move the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf this entry is vacant, inserts a new entry with the …\nSimilarly to <code>Entry::or_insert</code>, if this entry is occupied, …\nSimilar to <code>Entry::or_insert</code>, but accepts a function to …\nSimilarly to <code>Entry::or_insert_with</code>, if this entry is …\nIf the given key is not in this map, inserts the key / …\nReplaces the entry’s key with the key provided to …\nReplaces this entry’s key with the key provided to …\nIf an entry with this key exists, move it to the back of …\nIf an entry with this key exists, move it to the front of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInserts the given value into the set.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdds the given value to the set, replacing the existing …\nIf the returned entry is vacant, it will always have room …\nReturns the argument unchanged.\nRetrieve the given key, marking it as recently used and …\nRetrieve the given key, marking it as recently used and …\nInsert a new value into the <code>LruCache</code>.\nCalls <code>U::from(self)</code>.\nCreate a new unbounded <code>LruCache</code> that does not …\nGet the value for the given key, <em>without</em> marking the value …\nGet the value for the given key mutably, <em>without</em> marking …\nThe constructed raw entry is never automatically moved to …\nIf the constructed raw entry is vacant, it will always …\nRemove the least recently used entry and return it.\nSet the new cache capacity for the <code>LruCache</code>.")
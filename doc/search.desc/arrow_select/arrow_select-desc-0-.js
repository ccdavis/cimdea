searchState.loadedDescShard("arrow_select", 0, "Arrow selection kernels\nDefines concat kernel for <code>ArrayRef</code>\nDefines filter kernels\nDefines take kernel for Array\nDefines windowing functions, like <code>shift</code>ing\nConcatenate multiple Array of the same type into a single …\nConcatenates <code>batches</code> together into a single <code>RecordBatch</code>.\nFunction that can filter arbitrary arrays\nA builder to construct <code>FilterPredicate</code>\nA filtering predicate that can be applied to an <code>Array</code>\nAn iterator of <code>(usize, usize)</code> each representing an interval\nConstruct the final <code>FilterPredicate</code>\nReturns a prepared function optimized to filter multiple …\nNumber of rows being selected based on this <code>FilterPredicate</code>\nFilters an Array, returning elements matching the filter …\nSelects rows from <code>values</code> based on this <code>FilterPredicate</code>\nReturns a new RecordBatch with arrays containing only …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>FilterBuilder</code> that can be used to construct a …\nCompute an optimised representation of the provided <code>filter</code> …\nRemove null values by do a bitmask AND operation with null …\nTakes elements by index from a list of <code>Array</code>, creating a …\nCopies original array, setting validity bit to false if a …\nOptions that define how <code>take</code> should behave\nPerform bounds check before taking indices from values. If …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTake elements by index from Array, creating a new Array …\nTake rows by index from <code>RecordBatch</code> and returns a new …\nShifts array by defined number of items (to left or right) …\nZip two arrays by some boolean mask. Where the mask …")
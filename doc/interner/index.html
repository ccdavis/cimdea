<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="interner"><title>interner - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="interner" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../interner/index.html">interner</a><span class="version">0.2.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">interner</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/interner/lib.rs.html#1-295">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="interner"><a class="doc-anchor" href="#interner">§</a>interner</h2>
<p><img src="https://img.shields.io/badge/unsafe-forbid-success" alt="interner forbids unsafe code" />
<a href="https://crates.io/crates/interner"><img src="https://img.shields.io/crates/v/interner.svg" alt="crate version" /></a>
<a href="https://github.com/khonsulabs/interner/actions?query=workflow:Tests"><img src="https://img.shields.io/github/actions/workflow/status/khonsulabs/interner/tests.yml?branch=main" alt="Live Build Status" /></a>
<a href="https://khonsulabs.github.io/interner/coverage/"><img src="https://khonsulabs.github.io/interner/coverage/badge.svg" alt="HTML Coverage Report for main branch" /></a>
<a href="https://docs.rs/interner"><img src="https://img.shields.io/badge/docs-main-informational" alt="Documentation" /></a></p>
<p>An interning crate for Rust with no dependencies and no unsafe code
(<code>#![forbid(unsafe_code)]</code>). Most existing interning crates only offer interning
strings. This crate allows interning paths and byte buffers as well.</p>
<h3 id="how-this-crate-works"><a class="doc-anchor" href="#how-this-crate-works">§</a>How this crate works</h3>
<p>This crate uses a <code>HashSet</code> and a <code>Vec</code> to store its entries. When a value is
looked up, if it cannot be found in the <code>HashSet</code>, it is assigned a slot in the
<code>Vec</code>. Future lookups will return a clone to the <code>Arc</code>-wrapped data.</p>
<p>When the final reference to a <code>Pooled&lt;T&gt;</code> value is dropped, the pool’s <code>HashMap</code>
has the value removed and the <code>Vec</code>’s slot is made available for re-use.</p>
<p>This crate does not do sub-value interning. Each value is stored independently
with its own allocation.</p>
<h3 id="hash-for-pooled-values"><a class="doc-anchor" href="#hash-for-pooled-values">§</a><code>Hash</code> for Pooled Values</h3>
<p>The <code>Pooled&lt;T&gt;</code> type implements <code>Hash</code> by hashing its internal unique id rather
than using <code>T::hash()</code>. This allows pooled objects to be used as efficent keys
in hash maps and sets.</p>
<p>Because <code>T::hash()</code> is different than <code>Pooled&lt;T&gt;::hash()</code>, <code>Pooled&lt;T&gt;</code> does not
implement <code>Borrow&lt;T&gt;</code>. This prevents using an <code>&amp;str</code> to look up a value in a
<code>HashMap</code>.</p>
<p>Another important caveat of using <code>Pooled&lt;T&gt;</code> values as keys in a hash-based
collection is that all <code>Pooled&lt;T&gt;</code> values must be from the same pool. Using
values from separate pools will cause lookups to be unable to find the contained
keys in most situations. When using this unsupported flow, incorrect matches
will never occur because <code>Pooled&lt;T&gt;::eq()</code> is implemented to verify the values
are from the same pool, otherwise the underlying values are compared.</p>
<h3 id="globally-interned-strings"><a class="doc-anchor" href="#globally-interned-strings">§</a>Globally Interned Strings</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>interner::global::{GlobalString, GlobalPool};

<span class="kw">static </span>STRINGS: GlobalPool&lt;String&gt; = GlobalPool::new();

<span class="kw">let </span>my_string = STRINGS.get(<span class="string">"hello"</span>);
<span class="kw">let </span>other_copy = STRINGS.get(String::from(<span class="string">"hello"</span>));

<span class="comment">// Both `my_string` and `other_copy` are pointing to the same underlying string.
</span><span class="macro">assert!</span>(GlobalString::ptr_eq(<span class="kw-2">&amp;</span>my_string, <span class="kw-2">&amp;</span>other_copy));</code></pre></div>
<h3 id="interned-strings-from-a-stringpool"><a class="doc-anchor" href="#interned-strings-from-a-stringpool">§</a>Interned Strings from a StringPool</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>interner::shared::{StringPool, SharedString};

<span class="kw">let </span>pool = StringPool::default();
<span class="kw">let </span>my_string = pool.get(<span class="string">"hello"</span>);
<span class="kw">let </span>other_copy = pool.get(String::from(<span class="string">"hello"</span>));

<span class="comment">// Both `my_string` and `other_copy` are pointing to the same underlying string.
</span><span class="macro">assert!</span>(SharedString::ptr_eq(<span class="kw-2">&amp;</span>my_string, <span class="kw-2">&amp;</span>other_copy));</code></pre></div>
<h3 id="globally-interned-paths"><a class="doc-anchor" href="#globally-interned-paths">§</a>Globally Interned Paths</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::path::{Path, PathBuf};
<span class="kw">use </span>interner::global::{GlobalPath, GlobalPool};

<span class="kw">static </span>PATHS: GlobalPool&lt;PathBuf&gt; = GlobalPool::new();

<span class="kw">let </span>my_path = PATHS.get(Path::new(<span class="string">"hello"</span>));
<span class="kw">let </span>other_copy = PATHS.get(PathBuf::from(<span class="string">"hello"</span>));

<span class="comment">// Both `my_path` and `other_copy` are pointing to the same underlying path.
</span><span class="macro">assert!</span>(GlobalPath::ptr_eq(<span class="kw-2">&amp;</span>my_path, <span class="kw-2">&amp;</span>other_copy));</code></pre></div>
<h3 id="interned-paths-from-a-pathpool"><a class="doc-anchor" href="#interned-paths-from-a-pathpool">§</a>Interned Paths from a PathPool</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::path::{Path, PathBuf};
<span class="kw">use </span>interner::shared::{PathPool, SharedPath};

<span class="kw">let </span>pool = PathPool::default();
<span class="kw">let </span>my_string = pool.get(Path::new(<span class="string">"hello"</span>));
<span class="kw">let </span>other_copy = pool.get(PathBuf::from(<span class="string">"hello"</span>));

<span class="comment">// Both `my_path` and `other_copy` are pointing to the same underlying path.
</span><span class="macro">assert!</span>(SharedPath::ptr_eq(<span class="kw-2">&amp;</span>my_string, <span class="kw-2">&amp;</span>other_copy));</code></pre></div>
<h3 id="globally-interned-byte-buffers"><a class="doc-anchor" href="#globally-interned-byte-buffers">§</a>Globally Interned Byte Buffers</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>interner::global::{GlobalBuffer, GlobalPool};

<span class="kw">static </span>BUFFERS: GlobalPool&lt;Vec&lt;u8&gt;&gt; = GlobalPool::new();

<span class="kw">let </span>my_buffer = BUFFERS.get(<span class="kw-2">&amp;</span><span class="string">b"hello"</span>[..]);
<span class="kw">let </span>other_copy = BUFFERS.get(<span class="string">b"hello"</span>.to_vec());

<span class="comment">// Both `my_buffer` and `other_copy` are pointing to the same underlying path.
</span><span class="macro">assert!</span>(GlobalBuffer::ptr_eq(<span class="kw-2">&amp;</span>my_buffer, <span class="kw-2">&amp;</span>other_copy));</code></pre></div>
<h3 id="interned-byte-buffers-from-a-bufferpool"><a class="doc-anchor" href="#interned-byte-buffers-from-a-bufferpool">§</a>Interned Byte Buffers from a BufferPool</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>interner::shared::{BufferPool, SharedBuffer};

<span class="kw">let </span>pool = BufferPool::default();
<span class="kw">let </span>my_buffer = pool.get(<span class="kw-2">&amp;</span><span class="string">b"hello"</span>[..]);
<span class="kw">let </span>other_copy = pool.get(<span class="string">b"hello"</span>.to_vec());

<span class="comment">// Both `my_path` and `other_copy` are pointing to the same underlying path.
</span><span class="macro">assert!</span>(SharedBuffer::ptr_eq(<span class="kw-2">&amp;</span>my_buffer, <span class="kw-2">&amp;</span>other_copy));</code></pre></div>
<h3 id="open-source-licenses"><a class="doc-anchor" href="#open-source-licenses">§</a>Open-source Licenses</h3>
<p>This project, like all projects from <a href="https://khonsulabs.com/">Khonsu Labs</a>, are
open-source. This repository is available under the <a href="./LICENSE-MIT">MIT License</a>
or the <a href="./LICENSE-APACHE">Apache License 2.0</a>.</p>
<p>To learn more about contributing, please see <a href="./CONTRIBUTING.md">CONTRIBUTING.md</a>.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="global/index.html" title="mod interner::global">global</a></div><div class="desc docblock-short">Global interning pools.</div></li><li><div class="item-name"><a class="mod" href="shared/index.html" title="mod interner::shared">shared</a></div><div class="desc docblock-short">Shared interning pools that have no global state.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Pooled.html" title="struct interner::Pooled">Pooled</a></div><div class="desc docblock-short">A type that ensures only one copy of each value exists in its pool, enabling
quicker lookups by not requiring full comparisons.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.PoolKind.html" title="trait interner::PoolKind">PoolKind</a></div><div class="desc docblock-short">A kind of interning pool. Currently there are only two types of pools:</div></li></ul></section></div></main></body></html>